<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE-edge">
    <meta name="viewport" content="with=device-width, intial-scale=1.0">
    <link rel="stylesheet" href="style.css">

</head>

<body>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js'></script>
    <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2666677/OrbitControls.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js'></script>
    <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2666677/CannonHelper.js'></script>
    <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2666677/toon3d.js'></script>
    <script type="module">
var scene, camera, renderer, world, helper, vehicle, dt, light, lightOffset;

init();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xaaaaff );
  
  camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );
  camera.position.set(0, 10, 15);
  
  const ambient = new THREE.HemisphereLight(0x555555, 0xFFFFFF);
  scene.add(ambient);

  light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(1,1.25,1.25);
  light.castShadow = true;
  const size = 15;
  light.shadow.left = -size;
  light.shadow.bottom = -size;
  light.shadow.right = size;
  light.shadow.top = size;
  scene.add(light);
  scene.background = new THREE.CubeTextureLoader()
            .setPath('../skybox/')
            .load( [
                'bkg1_right.png',
                'bkg1_left.png',
                'bkg1_top.png',
                'bkg1_bot.png',
                'bkg1_front.png',
                'bkg1_back.png',
            ] );
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth,window.innerHeight);
            document.body.appendChild(renderer.domElement);
  
  initPhysics();

  onWindowResize();

  window.addEventListener( 'resize', onWindowResize, false );
  const joystick = new JoyStick({
    game: this,
    onMove: onMove
  });
  
  update();
}


            
        

           
function onMove( forward, turn ){
  const maxSteerVal = 0.5;
  const maxForce = 500;
  const brakeForce = 5;

  const force = maxForce * forward;
  const steer = maxSteerVal * -turn;

  if (forward!=0){
    vehicle.setBrake(0, 0);
    vehicle.setBrake(0, 1);
    vehicle.setBrake(0, 2);
    vehicle.setBrake(0, 3);

    vehicle.applyEngineForce(force, 2);
    vehicle.applyEngineForce(force, 3);
  }else{
    vehicle.setBrake(brakeForce, 0);
    vehicle.setBrake(brakeForce, 1);
    vehicle.setBrake(brakeForce, 2);
    vehicle.setBrake(brakeForce, 3);
  }

  vehicle.setSteeringValue(steer, 0);
  vehicle.setSteeringValue(steer, 1); 
}

function initPhysics(){
  world = new CANNON.World();
	helper = new CannonHelper( scene, world );
  
  dt = 1/60;
		
	world.broadphase = new CANNON.SAPBroadphase(world);
	world.gravity.set(0, -10, 0);
  world.defaultContactMaterial.friction = 0;

  const groundMaterial = new CANNON.Material("groundMaterial");
  const wheelMaterial = new CANNON.Material("wheelMaterial");
  const wheelGroundContactMaterial = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
    friction: 0.3,
    restitution: 0,
    contactEquationStiffness: 1000
  });

  // We must add the contact materials to the world
  world.addContactMaterial(wheelGroundContactMaterial);

  const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2));
  const chassisBody = new CANNON.Body({ mass: 150, material: groundMaterial });
  chassisBody.angularDamping = 0.9;
  chassisBody.addShape(chassisShape);
  chassisBody.position.set(0, 4, 0);
  helper.addVisual(chassisBody, 0x0000aa, 'car');
  light.target = chassisBody.threemesh;
  lightOffset = chassisBody.threemesh.position.clone().sub(light.position);

 


  const options = {
    radius: 0.5,
    directionLocal: new CANNON.Vec3(0, -1, 0),
    suspensionStiffness: 30,
    suspensionRestLength: 0.8,
    frictionSlip: 1,
    dampingRelaxation: 2.3,
    dampingCompression: 4.4,
    maxSuspensionForce: 100000,
    rollInfluence:  0.01,
    axleLocal: new CANNON.Vec3(-1, 0, 0),
    chassisConnectionPointLocal: new CANNON.Vec3(1, 1, 0),
    maxSuspensionTravel: 0.3,
    customSlidingRotationalSpeed: 30,
    useCustomSlidingRotationalSpeed: true
  };

  // Create the vehicle
  vehicle = new CANNON.RaycastVehicle({
    chassisBody: chassisBody,
    indexRightAxis: 0,
    indexUpAxis: 1,
    indexForwardAxis: 2
  });

  options.chassisConnectionPointLocal.set(1, 0, -1);
  vehicle.addWheel(options);

  options.chassisConnectionPointLocal.set(-1, 0, -1);
  vehicle.addWheel(options);

  options.chassisConnectionPointLocal.set(1, 0, 1);
  vehicle.addWheel(options);

  options.chassisConnectionPointLocal.set(-1, 0, 1);
  vehicle.addWheel(options);

  vehicle.addToWorld(world);






        const groundShape = new CANNON.Plane();
        
        const groundBody = new CANNON.Body({mass:0});
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
        
        world.addBody(groundBody);
        helper.addVisual(groundBody, 0x00ff00, 'ground');





        const rampShape = new CANNON.Box(new CANNON.Vec3(5,1,10));
            const rampBody = new CANNON.Body({mass: 0,shape: rampShape, material: groundMaterial});
            rampBody.position = new CANNON.Vec3(0,0.5,15);
            rampBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/20);
            world.addBody(rampBody);
            const rampMat = new THREE.MeshStandardMaterial({color:0xd3c3a2});
            const rampGeo = new THREE.BoxGeometry(10,2,20);
            const rampMash = new THREE.Mesh(rampGeo,rampMat);
            scene.add(rampMash);
            rampMash.position.copy(rampBody.position);
            rampMash.quaternion.copy(rampBody.quaternion);


}       

function onWindowResize( event ) {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function cameraupd(){
    var followCam = new THREE.Object3D();
       
        
        camera.lookAt(vehicle.chassisBody.position);
        
        scene.add(followCam);
        followCam.parent = vehicle.chassisBody.threemesh;
        helper.shadowTarget = vehicle.chassisBody.threemesh;

        
    

        
     




}




function update() {
  requestAnimationFrame( update );
  world.step(dt);
  light.position.copy(vehicle.chassisBody.threemesh.position).sub(lightOffset);
  cameraupd();
  
  camera.lookAt( vehicle.chassisBody.threemesh.position );
  helper.update( );
  renderer.render( scene, camera );
}


    </script>


        
   

    


</body>

</html>